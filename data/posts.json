[
  {
    "id": 1767107281461,
    "title": "Chess Engine + ML",
    "content": "I built a chess engine in C++ that plays at approximately 1500 ELO using both classical search algorithms and modern machine learning. The engine has two evaluation modes: a classical engine using hand-crafted evaluation with NegaMax search, Alpha-Beta pruning, and quiescence search, and a neural network trained on over 1 million (change!!) chess positions from Lichess games. \n\nThis post is structured in two parts. First, I'll walk through the classical engine architecture - the core algorithms, move ordering optimizations, and debugging challenges that taught me as much about software engineering as they did about chess. Then, I'll cover the machine learning pipeline: data collection and preprocessing, neural network architecture, training on 1M positions(change!!!), and the production integration using PyTorch and ONNX Runtime to deploy the model in C++.\n\nYou can try both engines at [ENTER URL] - the interface lets you toggle between classical and neural network evaluation modes to compare their playing styles.\n\n\nPart 1: Core Search Architecture \n\nSection 1.1:  NegaMax with Alpha-Beta Pruning - The Core Algorithm\nThe foundation of the classical engine is NegaMax. Instead of alternating between maximizing and minimizing perspectives, NegaMax always maximizes from the current player's viewpoint by negating the opponent's score. Next, we have Alpha-beta pruning which represents the best score we've guaranteed so far (lower bound), while beta is the opponent's best alternative (upper bound). If we find a move scoring >= beta, the opponent will avoid this position, so we can stop searching this branch entirely. This cuts the search tree by 50-75%, letting the engine search 2-3 plies deeper.\n\nSection 1.2:  Quiescence Search - Avoiding Tactical Blindness\nMoving further, we implemented quiescence search in order to avoid the horizon effect. The horizon effect is when the engine doesn't search far enough depth wise during tactical sequences. Why? Because it sees a good move and plays it - without seeing what comes soon after that move. This can lead to bad play by the engine. To negate this I implemented quiescence search that extends beyond the nominal depth, examining only tactical moves until the position becomes quiet. With this, I integrated delta pruning. This ensures that captures are skipped that can't improve the position. For example, If the current position evaluates to -200, and we can capture a pawn worth +100, the best we could hope for is -100. But if alpha is already +50 (we've found a line guaranteeing us +50), this capture is futile - it can't possibly beat what we already have. So we skip it.\n\nSection 1.3:  Transposition Tables - Eliminating Redundant Work \nAnother piece to the puzzle was implementing a transposition table. Chess positions can transpose - reach the same position through different move orders. A transposition table is a massive hash table (1M+ entries) that caches position evaluations to avoid redundant work. The table uses Zobrist hashing - a technique where each piece on each square has a random 64-bit number. The position's hash is the XOR of all these numbers, making hash updates O(1) during move make/unmake.\n\n\nPart 2:  Move Ordering \n\nAlpha-beta pruning's effectiveness depends entirely on examining good moves first. With optimal move ordering, the first move causes a beta cutoff 50-60% of the time. With poor ordering, this drops to 10-20%, forcing the engine to search 3-5x more positions. In order to improve upon this I implemented a multi-tier move ordering system: \n\t1. Transposition Table Move (highest priority) \n\t\tâ If we've seen this position before, try the best move from that search first.\n\t2. Static Exchange Evaluation (SEE) for Captures \n\t\tâ Not all captures are good. SEE simulates the complete capture sequence to determine net material .\n\t3. Killer Moves\n\t\tâ This heuristic (did I say this right) remembers quiet moves that caused beta cutoffs at the same depth in sibling branches. If Nf3 caused a cutoff in one line, it's likely strong in similar positions. Each depth stores 2 killer moves. \n\t4. History Heuristic \n\t\tâ Tracks how often each move (from-square to to-square) has caused beta cutoffs across the entire search. Squaring the depth gives more weight to stronger moves that work deeper in the tree.\n\nPart 3:  Position Evaluation \n\nOnce the search reaches a leaf node, the evaluation function determines \"how good is this position?\" This is where we teach the engine what makes a chess position strong or weak. For example, a knight on the rim is worth maybe 280, whereas a centralized knight is worth 360.\n\nPawn Structure \n\t- Doubled pawns:  -10 penalty\n\t- Isolated pawns:  -15 penalty \n\t- Passed pawns:  +20-50 depending on how advanced \n\nKing Safety \n\t- Castled: +20 bonus\n\t- Pawn shield: +5 per pawn in front of king\n\t- Becomes less important in the endgame when king should activate \n\nCenter Control provides a bonus for pieces controlling central squares -- encouraging piece activity. \n\nMobility counts pseudo-legal moves for each piece. More moves = more options = better position. This is expensive to compute, so I made it optional with a compile-time flag.\n\n\nPart 4:  Performance Metrics \n\nPart 4.1:  Raw Search Performance\nThe engine achieves approximately 12,000-15,000 nodes per second on consumer hardware after optimizations. For context, modern engines at this strength level typically reach 50,000-500,000 nodes/second, so there's significant room for improvement. However, raw speed isn't everything - what matters more is how efficiently those nodes are being searched.\n\t\nPart 4.2:  Move Ordering Effectiveness\nThe critical metric for search efficiency is the first-move cutoff rate - how often does the first move examined at a node cause a beta cutoff, allowing us to skip searching all remaining moves?\n\nHere's how my engine performs across different position types:\n\nPosition Type:       First-Move Cutoff     Nodes/Second  \nOpening                             60.7%                     15,000\nEarly middlegame             42%                       13,500\nTactical complexity           13.7%                    6,384\nQuiet endgame                  58%                       14,800\n\nThat third row was the smoking gun. In tactically sharp positions with multiple captures available, move ordering completely broke down.\n\nPart 4.3:  The Static Exchange Evaluation (SEE) Impact\nThe problem was clear: the engine was trying captures in the wrong order. Before SEE, all captures were scored equally high (1,000,000+ points) using simple MVV-LVA (Most Valuable Victim - Least Valuable Attacker). This meant:\n\tâ¢ Knight takes queen = 1,089,680 points \n\tâ¢ Knight takes pawn but hangs the knight = 1,009,680 points (terrible)\nBoth captures scored over 1 million, so the bad capture was still examined before killer moves (800,000-900,000 points). In the tactical test position, this caused catastrophic move ordering. \n\nThis single optimization essentially doubled search efficiency in tactical positions by ensuring the engine examines promising moves before wasting time on captures that lose material.\n\nPart 4.4 Overall Playing Strength \nThe classical engine plays at approximately 1500 ELO based on testing against rated opponents. Key strengths:\n\tâ¢ Solid tactical vision (rarely hangs pieces)\n\tâ¢ Reasonable positional understanding from PST\n\tâ¢ Good king safety in opening/middlegame\n\tâ¢ Decent endgame technique with passed pawn evaluation\nWeaknesses:\n\tâ¢ Occasionally misses deep combinations (6+ moves)\n\tâ¢ Positional evaluation could be more sophisticated\n\tâ¢ Limited opening book knowledge\n\tâ¢ Search speed still below top engines at this level",
    "category": "tech",
    "created": "2025-12-30T15:08:01.461Z",
    "lastModified": "2025-12-30T15:08:42.909Z",
    "pinnedSlots": {
      "discourse": null,
      "tech": null,
      "history": null,
      "literature": null
    }
  },
  {
    "id": 1767037945031,
    "title": "test",
    "content": "test",
    "category": "tech",
    "created": "2025-12-29T19:52:25.031Z",
    "lastModified": "2025-12-29T19:52:25.031Z",
    "pinnedSlots": {
      "discourse": 1,
      "tech": 5,
      "history": null,
      "literature": null
    }
  }
]